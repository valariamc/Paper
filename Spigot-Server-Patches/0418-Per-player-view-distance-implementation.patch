From a4e7c07e0a22b49904201e27b8d7454f28c2367a Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Fri, 27 Dec 2019 14:20:40 -0800
Subject: [PATCH] Per player view distance implementation

This patch implements CraftPlayer#setViewDistance and
CraftPlayer#getViewDistance

This patch replaces the existing system to handle player tickets
and chunk sending to players.
 Most of the work is pulled by two
PlayerAreaMap's controlling: a radius for sending chunks and a radius
for adding player tickets. Currently the difference between the two
radii is just 1.
Normal vanilla has a difference of two, but this
causes issues where outer chunks in the view distance sometimes
do not send. This is because the outer radius is not guaranteed to
be at ticket level 32, which is required to be sent to players.

The ticket manager in ChunkMapDistance for players is no longer used and
is entirely replaced by the ticket distance map. The ticket tracker also
adds a configurable chunk load rate per player, as well as ensuring that
a minimum number of chunks are loaded. Vanilla has issues where under
low TPS the maximum number of chunks that are even queued to load is
very small (around 6 chunks loaded per second in my testing). Obviously
at such low load rates player experience drops hard.

This patch moves the order of the distance map update in movePlayer
until after a client is sent a center section packet. This is required
to avoid the client rejecting chunks it receives when teleporting.

diff --git a/src/main/java/co/aikar/timings/WorldTimingsHandler.java b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
index e25544f11..d41c3bd33 100644
--- a/src/main/java/co/aikar/timings/WorldTimingsHandler.java
+++ b/src/main/java/co/aikar/timings/WorldTimingsHandler.java
@@ -75,6 +75,8 @@ public class WorldTimingsHandler {
     public final Timing chunkUnloadPOISerialization;
     public final Timing chunkUnloadDataSave;
 
+    public final Timing playerTicketTrackerTick;
+
     public WorldTimingsHandler(World server) {
         String name = server.worldData.getName() +" - ";
 
@@ -146,6 +148,8 @@ public class WorldTimingsHandler {
         chunkUnloadPrepareSave = Timings.ofSafe(name + "Chunk unload - Async Save Prepare");
         chunkUnloadPOISerialization = Timings.ofSafe(name + "Chunk unload - POI Data Serialization");
         chunkUnloadDataSave = Timings.ofSafe(name + "Chunk unload - Data Serialization");
+
+        playerTicketTrackerTick = Timings.ofSafe("Player ticket tracker tick");
     }
 
     public static Timing getTickList(WorldServer worldserver, String timingsType) {
diff --git a/src/main/java/com/destroystokyo/paper/PaperConfig.java b/src/main/java/com/destroystokyo/paper/PaperConfig.java
index 1d7d1ffbf..45f7cf162 100644
--- a/src/main/java/com/destroystokyo/paper/PaperConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperConfig.java
@@ -425,4 +425,13 @@ public class PaperConfig {
             */
         }
     }
+
+    public static int maxChunkLoadsPerPlayer;
+
+    private static void maxChunkLoadsPerPlayer() {
+        maxChunkLoadsPerPlayer = getInt("settings.max-pending-chunk-tickets-per-player", 49);
+        if (maxChunkLoadsPerPlayer <= -1) {
+            maxChunkLoadsPerPlayer = Integer.MAX_VALUE;
+        }
+    }
 }
diff --git a/src/main/java/net/minecraft/server/ChunkMapDistance.java b/src/main/java/net/minecraft/server/ChunkMapDistance.java
index 9f98c6573..2d38d8420 100644
--- a/src/main/java/net/minecraft/server/ChunkMapDistance.java
+++ b/src/main/java/net/minecraft/server/ChunkMapDistance.java
@@ -26,12 +26,12 @@ import org.apache.logging.log4j.Logger;
 public abstract class ChunkMapDistance {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2;
+    private static final int b = 33 + ChunkStatus.a(ChunkStatus.FULL) - 2; public static int getPlayerTicketLevel() { return ChunkMapDistance.b; } // Paper - OBFHELPER
     private final Long2ObjectMap<ObjectSet<EntityPlayer>> c = new Long2ObjectOpenHashMap();
     public final Long2ObjectOpenHashMap<ArraySetSorted<Ticket<?>>> tickets = new Long2ObjectOpenHashMap();
     private final ChunkMapDistance.a e = new ChunkMapDistance.a();
     private final ChunkMapDistance.b f = new ChunkMapDistance.b(8);
-    private final ChunkMapDistance.c g = new ChunkMapDistance.c(33);
+    //private final ChunkMapDistance.c g = new ChunkMapDistance.c(33); // Paper - no longer used
     private final java.util.Queue<PlayerChunk> pendingChunkUpdates = new java.util.LinkedList<>(); // PAIL pendingChunkUpdates // Paper - use a queue
     private final ChunkTaskQueueSorter i;
     private final Mailbox<ChunkTaskQueueSorter.a<Runnable>> j;
@@ -40,6 +40,11 @@ public abstract class ChunkMapDistance {
     private final Executor m;
     private long currentTick;
 
+    // Paper start
+    protected PlayerChunkMap chunkMap;
+    protected final ChunkMapDistance.TicketTracker playerTicketHandler = new TicketTracker();
+    // Paper end
+
     protected ChunkMapDistance(Executor executor, Executor executor1) {
         executor1.getClass();
         Mailbox<Runnable> mailbox = Mailbox.a("player ticket throttler", executor1::execute);
@@ -85,7 +90,7 @@ public abstract class ChunkMapDistance {
 
     public boolean a(PlayerChunkMap playerchunkmap) {
         this.f.a();
-        this.g.a();
+        //this.g.a(); // Paper - no longer used
         int i = Integer.MAX_VALUE - this.e.a(Integer.MAX_VALUE);
         boolean flag = i != 0;
 
@@ -219,7 +224,7 @@ public abstract class ChunkMapDistance {
             return new ObjectOpenHashSet();
         })).add(entityplayer);
         this.f.b(i, 0, true);
-        this.g.b(i, 0, true);
+        //this.g.b(i, 0, true); // Paper - no longer used
     }
 
     public void b(SectionPosition sectionposition, EntityPlayer entityplayer) {
@@ -230,7 +235,7 @@ public abstract class ChunkMapDistance {
         if (objectset.isEmpty()) {
             this.c.remove(i);
             this.f.b(i, Integer.MAX_VALUE, false);
-            this.g.b(i, Integer.MAX_VALUE, false);
+            //this.g.b(i, Integer.MAX_VALUE, false); // Paper - no longer used
         }
 
     }
@@ -248,9 +253,195 @@ public abstract class ChunkMapDistance {
         return s;
     }
 
+
     protected void a(int i) {
-        this.g.a(i);
+        this.setGlobalViewDistance(i, this.chunkMap); // Paper
+    }
+
+    // Paper start - per player view distance
+    protected void setGlobalViewDistance(int viewDistance, PlayerChunkMap chunkMap) {
+        this.chunkMap = chunkMap;
+    }
+
+    class TicketTracker {
+
+        private final it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap chunkReferenceMap = new it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap(8192, 0.25f);
+        {
+            this.chunkReferenceMap.defaultReturnValue(-1);
+        }
+        private final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap lastLoadedRadiusByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        {
+            this.lastLoadedRadiusByPlayer.defaultReturnValue(-1);
+        }
+
+        private final it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap pendingChunkLoadsByPlayer = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(512, 0.5f);
+        private final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap lastChunkPositionByPlayer = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap(512, 0.5f);
+        {
+            this.lastChunkPositionByPlayer.defaultReturnValue(-1L);
+        }
+
+        private final java.util.List<EntityPlayer> players = new java.util.ArrayList<>(256);
+
+        private boolean tryQueueChunk(int chunkX, int chunkZ, EntityPlayer player) {
+            long coordinate = MCUtil.getCoordinateKey(chunkX, chunkZ);
+            if (this.chunkReferenceMap.putIfAbsent(coordinate, player.getId()) == -1) {
+                ChunkMapDistance.this.addTicket(coordinate, new Ticket<>(TicketType.PLAYER, ChunkMapDistance.getPlayerTicketLevel(), new ChunkCoordIntPair(chunkX, chunkZ)));
+                return true;
+            }
+            return false;
+        }
+
+        public void tick() {
+            PlayerChunkMap chunkMap = ChunkMapDistance.this.chunkMap;
+            for (EntityPlayer player : this.players) {
+                int playerId = player.getId();
+                int lastLoadedRadius = this.lastLoadedRadiusByPlayer.get(playerId);
+                int pendingChunkLoads = this.pendingChunkLoadsByPlayer.get(playerId);
+                long lastChunkPos = this.lastChunkPositionByPlayer.get(playerId);
+                long currentChunkPos = chunkMap.playerViewDistanceTicketMap.getLastCoordinate(player);
+
+                if (currentChunkPos == Long.MIN_VALUE) {
+                    // not tracking for whatever reason...
+                    continue;
+                }
+
+                int newX = MCUtil.getCoordinateX(currentChunkPos);
+                int newZ = MCUtil.getCoordinateZ(currentChunkPos);
+
+                // handle movement
+                if (currentChunkPos != lastChunkPos && lastChunkPos != Long.MIN_VALUE) {
+                    int oldX = MCUtil.getCoordinateX(lastChunkPos);
+                    int oldZ = MCUtil.getCoordinateZ(lastChunkPos);
+
+                    int radiusDiff = Math.max(Math.abs(newX - oldX), Math.abs(newZ - oldZ));
+                    lastLoadedRadius = Math.max(-1, lastLoadedRadius - radiusDiff);
+                    this.lastChunkPositionByPlayer.put(playerId, currentChunkPos);
+                }
+
+                int maxChunkLoads = com.destroystokyo.paper.PaperConfig.maxChunkLoadsPerPlayer; // per-player limits instead of global?
+
+                if (pendingChunkLoads >= maxChunkLoads) {
+                    continue;
+                }
+
+                // handle movement
+
+                int radius = lastLoadedRadius + 1;
+
+                radius_loop:
+                for (int viewDistance = chunkMap.playerViewDistanceTicketMap.getLastViewDistance(player); radius <= viewDistance; ++radius) {
+                    for (int offset = 0; offset <= viewDistance; ++offset) {
+                        // try to load the chunks closest to the player by distance
+                        // so instead of going left->right on the x axis, we start at the center of the view distance square
+                        // and go left and right at the same time
+
+                        // try top 2 chunks
+                        // top left
+                        if (this.tryQueueChunk(newX - offset, newZ + radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // top right
+                        if (this.tryQueueChunk(newX + offset, newZ + radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try bottom 2 chunks
+
+                        // bottom left
+                        if (this.tryQueueChunk(newX - offset, newZ - radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // bottom right
+                        if (this.tryQueueChunk(newX + offset, newZ - radius, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try left 2 chunks
+
+                        // left down
+                        if (this.tryQueueChunk(newX - radius, newZ - offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // left up
+                        if (this.tryQueueChunk(newX - radius, newZ + offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // try right 2 chunks
+
+                        // right down
+                        if (this.tryQueueChunk(newX + radius, newZ - offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+
+                        // right up
+                        if (this.tryQueueChunk(newX + radius, newZ + offset, player)) {
+                            if (++pendingChunkLoads >= maxChunkLoads) {
+                                break radius_loop;
+                            }
+                        }
+                    }
+                }
+
+                int newLoadedRadius = radius - 1;
+                if (newLoadedRadius != lastLoadedRadius) {
+                    this.lastLoadedRadiusByPlayer.put(playerId, newLoadedRadius);
+                }
+                this.pendingChunkLoadsByPlayer.put(playerId, pendingChunkLoads);
+            }
+        }
+
+        public void addPlayer(EntityPlayer player) {
+            this.players.add(player);
+        }
+
+        public void removePlayer(EntityPlayer player) {
+            this.players.remove(player);
+            this.lastLoadedRadiusByPlayer.remove(player.getId());
+            this.pendingChunkLoadsByPlayer.remove(player.getId());
+            this.lastChunkPositionByPlayer.remove(player.getId());
+        }
+
+        public void onChunkSetEntityTicking(int chunkX, int chunkZ) {
+            long coordinate = MCUtil.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.get(coordinate);
+            if (playerReference != -1) {
+                this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                    return valueInMap - 1;
+                });
+            }
+        }
+
+        // this is invoked if and only if there are no other players in range of the chunk.
+        public void playerMoveOutOfRange(int chunkX, int chunkZ) {
+            long coordinate = MCUtil.getCoordinateKey(chunkX, chunkZ);
+            int playerReference = this.chunkReferenceMap.remove(coordinate);
+            if (playerReference != -1) {
+                this.pendingChunkLoadsByPlayer.computeIfPresent(playerReference, (Integer keyInMap, Integer valueInMap) -> {
+                    return valueInMap - 1;
+                });
+                ChunkMapDistance.this.removeTicket(coordinate, new Ticket<>(TicketType.PLAYER, ChunkMapDistance.getPlayerTicketLevel(), new ChunkCoordIntPair(chunkX, chunkZ)));
+            }
+        }
     }
+    // Paper end
 
     public int b() {
         this.f.a();
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 6e0d1d949..97950c6b6 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -619,6 +619,14 @@ public class ChunkProviderServer extends IChunkProvider {
         this.chunkMapDistance.purgeTickets();
         this.tickDistanceManager();
         this.world.timings.doChunkMap.stopTiming(); // Spigot
+        // Paper start
+        this.world.timings.playerTicketTrackerTick.startTiming();
+        try {
+            this.playerChunkMap.getChunkMapDistanceManager().playerTicketHandler.tick();
+        } finally {
+            this.world.timings.playerTicketTrackerTick.stopTiming();
+        }
+        // Paper end
         this.world.getMethodProfiler().exitEnter("chunks");
         this.world.timings.chunks.startTiming(); // Paper - timings
         this.tickChunks();
diff --git a/src/main/java/net/minecraft/server/EntityEnderDragon.java b/src/main/java/net/minecraft/server/EntityEnderDragon.java
index 3df8e30ec..b91658828 100644
--- a/src/main/java/net/minecraft/server/EntityEnderDragon.java
+++ b/src/main/java/net/minecraft/server/EntityEnderDragon.java
@@ -581,7 +581,7 @@ public class EntityEnderDragon extends EntityInsentient implements IMonster {
                 // Paper start
                 //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(); // Paper - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 865b4034d..79bfcfefb 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -102,6 +102,16 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     public final com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> cachedSingleHashSet; // Paper
 
+    // Paper start - per player view distance
+    public int viewDistance = -1;
+    public final int getEffectiveViewDistance() {
+        return this.viewDistance == -1 ? ((ChunkProviderServer)this.world.getChunkProvider()).playerChunkMap.viewDistance : this.viewDistance;
+    }
+    public final int getEffectiveViewDistance(final int dfl) {
+        return this.viewDistance == -1? dfl : this.viewDistance;
+    }
+    // Paper end
+
     public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
         super((World) worldserver, gameprofile);
         playerinteractmanager.player = this;
@@ -1742,8 +1752,13 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void a(ChunkCoordIntPair chunkcoordintpair) {
+        // Paper start add x, z parameters
+        this.sendChunkUnload(chunkcoordintpair.x, chunkcoordintpair.z);
+    }
+    public final void sendChunkUnload(int x, int z) {
+        // Paper end
         if (this.isAlive()) {
-            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(chunkcoordintpair.x, chunkcoordintpair.z));
+            this.playerConnection.sendPacket(new PacketPlayOutUnloadChunk(x, z)); // Paper
         }
 
     }
diff --git a/src/main/java/net/minecraft/server/EntityWither.java b/src/main/java/net/minecraft/server/EntityWither.java
index 2e95069c1..aa4787d39 100644
--- a/src/main/java/net/minecraft/server/EntityWither.java
+++ b/src/main/java/net/minecraft/server/EntityWither.java
@@ -210,7 +210,7 @@ public class EntityWither extends EntityMonster implements IRangedEntity {
                 // Paper start
                 //int viewDistance = ((WorldServer) this.world).spigotConfig.viewDistance * 16; // Paper - updated to use worlds actual view distance incase we have to uncomment this due to removal of player view distance API
                 for (EntityPlayer player : ((WorldServer)world).getPlayers()) {
-                    final int viewDistance = player.getViewDistance(); // TODO apply view distance api patch
+                    final int viewDistance = player.getEffectiveViewDistance(); // Paper - per player view distance
                     // Paper end
                     double deltaX = this.locX() - player.locX();
                     double deltaZ = this.locZ() - player.locZ();
diff --git a/src/main/java/net/minecraft/server/PlayerChunk.java b/src/main/java/net/minecraft/server/PlayerChunk.java
index 054778d0b..0ff497ed7 100644
--- a/src/main/java/net/minecraft/server/PlayerChunk.java
+++ b/src/main/java/net/minecraft/server/PlayerChunk.java
@@ -292,9 +292,50 @@ public class PlayerChunk {
     }
 
     private void a(Packet<?> packet, boolean flag) {
-        this.players.a(this.location, flag).forEach((entityplayer) -> {
-            entityplayer.playerConnection.sendPacket(packet);
-        });
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        if (this.players instanceof PlayerChunkMap) {
+            PlayerChunkMap chunkMap = ((PlayerChunkMap)this.players);
+            com.destroystokyo.paper.util.misc.PlayerAreaMap viewDistanceMap = ((PlayerChunkMap)this.players).playerViewDistanceBroadcastMap;
+            com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = viewDistanceMap.getObjectsInRange(this.location);
+            if (players == null) {
+                return;
+            }
+
+            if (flag) { // flag -> border only
+                Object[] backingSet = players.getBackingSet();
+                for (int i = 0, len = backingSet.length; i < len; ++i) {
+                    Object temp = backingSet[i];
+                    if (!(temp instanceof EntityPlayer)) {
+                        continue;
+                    }
+                    EntityPlayer player = (EntityPlayer)temp;
+                    int viewDistance = viewDistanceMap.getLastViewDistance(player);
+                    long lastPosition = viewDistanceMap.getLastCoordinate(player);
+
+                    int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - this.location.x);
+                    int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - this.location.z);
+
+                    if (Math.max(distX, distZ) == viewDistance) {
+                        player.playerConnection.sendPacket(packet);
+                    }
+                }
+            } else {
+                Object[] backingSet = players.getBackingSet();
+                for (int i = 0, len = backingSet.length; i < len; ++i) {
+                    Object temp = backingSet[i];
+                    if (!(temp instanceof EntityPlayer)) {
+                        continue;
+                    }
+                    EntityPlayer player = (EntityPlayer)temp;
+                    player.playerConnection.sendPacket(packet);
+                }
+            }
+
+            return;
+        }
+        // Paper end
     }
 
     public CompletableFuture<Either<IChunkAccess, PlayerChunk.Failure>> a(ChunkStatus chunkstatus, PlayerChunkMap playerchunkmap) {
@@ -486,6 +527,9 @@ public class PlayerChunk {
 
 
 
+                    // Paper start - per player view distance
+                    PlayerChunk.this.chunkMap.getChunkMapDistanceManager().playerTicketHandler.onChunkSetEntityTicking(this.location.x, this.location.z);
+                    // Paper end
 
                 }
                 return either;
diff --git a/src/main/java/net/minecraft/server/PlayerChunkMap.java b/src/main/java/net/minecraft/server/PlayerChunkMap.java
index 5d90ca690..a63da7513 100644
--- a/src/main/java/net/minecraft/server/PlayerChunkMap.java
+++ b/src/main/java/net/minecraft/server/PlayerChunkMap.java
@@ -78,7 +78,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     private final PlayerMap playerMap;
     public final Int2ObjectMap<PlayerChunkMap.EntityTracker> trackedEntities;
     private final Queue<Runnable> z;
-    int viewDistance; // Paper - private -> package private
+    int viewDistance; public final int getViewDistance() { return this.viewDistance; } // Paper - private -> package private // Paper - OBFHELPER
     public final com.destroystokyo.paper.util.PlayerMobDistanceMap playerMobDistanceMap; // Paper
 
     // CraftBukkit start - recursion-safe executor for Chunk loadCallback() and unloadCallback()
@@ -109,15 +109,43 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     // Paper start - distance maps
     private final com.destroystokyo.paper.util.misc.PooledLinkedHashSets<EntityPlayer> pooledLinkedPlayerHashSets = new com.destroystokyo.paper.util.misc.PooledLinkedHashSets<>();
 
+    // Paper start - per player view distance
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceBroadcastMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceTicketMap;
+    public final com.destroystokyo.paper.util.misc.PlayerAreaMap playerViewDistanceMap;
+
+    public void updateViewDistance(EntityPlayer player, int viewDistance) {
+        player.viewDistance = viewDistance;
+
+        int chunkX = MCUtil.getChunkCoordinate(player.locX());
+        int chunkZ = MCUtil.getChunkCoordinate(player.locZ());
+
+        int effectiveViewDistance = viewDistance == -1 ? this.viewDistance : viewDistance;
+
+        player.playerConnection.sendPacket(new PacketPlayOutViewDistance(effectiveViewDistance));
+
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveViewDistance + 1); // clients need chunk neighbours
+    }
+    // Paper end
+
     void addPlayerToDistanceMaps(EntityPlayer player) {
         this.updateMaps(player);
 
 
-
+        this.getChunkMapDistanceManager().playerTicketHandler.addPlayer(player); // Paper - per player view distance
     }
 
     void removePlayerFromDistanceMaps(EntityPlayer player) {
-
+        // Paper start - per player view distance
+        this.playerViewDistanceTicketMap.remove(player);
+        this.playerViewDistanceTicketMap.remove(player);
+        this.playerViewDistanceMap.remove(player);
+        this.getChunkMapDistanceManager().playerTicketHandler.removePlayer(player);
+        // Paper end
 
 
 
@@ -127,7 +155,14 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int chunkX = MCUtil.getChunkCoordinate(player.locX());
         int chunkZ = MCUtil.getChunkCoordinate(player.locZ());
 
-
+        // Paper start - per player view distance
+        int effectiveViewDistance = player.getEffectiveViewDistance(this.viewDistance);
+        if (!this.cannotLoadChunks(player)) {
+            this.playerViewDistanceTicketMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        }
+        this.playerViewDistanceMap.update(player, chunkX, chunkZ, effectiveViewDistance);
+        this.playerViewDistanceBroadcastMap.update(player, chunkX, chunkZ, effectiveViewDistance + 1);
+        // Paper end
 
 
     }
@@ -167,6 +202,30 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         this.m = new VillagePlace(new File(this.w, "poi"), datafixer, this.world); // Paper
         this.setViewDistance(i);
         this.playerMobDistanceMap = this.world.paperConfig.perPlayerMobSpawns ? new com.destroystokyo.paper.util.PlayerMobDistanceMap() : null; // Paper
+        // Paper start - per player view distance
+        this.playerViewDistanceTicketMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            null,
+            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                if (newState != null) {
+                    return;
+                }
+                PlayerChunkMap.this.chunkDistanceManager.playerTicketHandler.playerMoveOutOfRange(rangeX, rangeZ);
+            });
+        this.playerViewDistanceMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets);
+        final Packet[] tempPacket = new Packet[2];
+        this.playerViewDistanceBroadcastMap = new com.destroystokyo.paper.util.misc.PlayerAreaMap(this.pooledLinkedPlayerHashSets,
+            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, false, true); // unloaded, loaded
+                java.util.Arrays.fill(tempPacket, null);
+            },
+            (EntityPlayer player, int rangeX, int rangeZ, int currPosX, int currPosZ, int prevPosX, int prevPosZ,
+             com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> newState) -> {
+                PlayerChunkMap.this.sendChunk(player, rangeX, rangeZ, tempPacket, true, false); // unloaded, loaded
+                java.util.Arrays.fill(tempPacket, null);
+            });
+        // Paper end
     }
 
     public void updatePlayerMobTypeMap(Entity entity) {
@@ -898,9 +957,22 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                 this.u.getAndIncrement();
                 Packet<?>[] apacket = new Packet[2];
 
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    this.a(entityplayer, apacket, chunk);
-                });
+                // Paper start - per player view distance
+                // there can be potential desync with player's last mapped section and the view distance map, so use the
+                // view distance map here.
+                com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> players = PlayerChunkMap.this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+                if (players != null) {
+                    Object[] backingSet = players.getBackingSet();
+                    for (int i = 0, len = backingSet.length; i < len; ++i) {
+                        Object temp = backingSet[i];
+                        if (!(temp instanceof EntityPlayer)) {
+                            continue;
+                        }
+                        EntityPlayer player = (EntityPlayer)temp;
+                        this.a(player, apacket, chunk);
+                    }
+                }
+                // Paper end
                 return Either.left(chunk);
             });
         }, (runnable) -> {
@@ -1003,36 +1075,35 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     protected void setViewDistance(int i) {
-        int j = MathHelper.clamp(i + 1, 3, 33);
+        int j = MathHelper.clamp(i + 1, 3, 33) - 1; // Paper - we correctly handle view distance, no need to add 1
 
         if (j != this.viewDistance) {
             int k = this.viewDistance;
 
             this.viewDistance = j;
-            this.chunkDistanceManager.a(this.viewDistance);
-            ObjectIterator objectiterator = this.updatingChunks.values().iterator();
-
-            while (objectiterator.hasNext()) {
-                PlayerChunk playerchunk = (PlayerChunk) objectiterator.next();
-                ChunkCoordIntPair chunkcoordintpair = playerchunk.i();
-                Packet<?>[] apacket = new Packet[2];
-
-                this.a(chunkcoordintpair, false).forEach((entityplayer) -> {
-                    int l = b(chunkcoordintpair, entityplayer, true);
-                    boolean flag = l <= k;
-                    boolean flag1 = l <= this.viewDistance;
-
-                    this.sendChunk(entityplayer, chunkcoordintpair, apacket, flag, flag1);
-                });
+            this.chunkDistanceManager.setGlobalViewDistance(this.viewDistance, this); // Paper - per player view distance
+            // Paper start
+            if (this.world != null && this.world.players != null) { // ... called inside constructor, where these may not be initialized
+                for (EntityPlayer player : this.world.players) {
+                    if (player.viewDistance == -1) {
+                        this.updateViewDistance(player, -1); // distance map will send/unload chunks
+                    }
+                }
+                // Paper end
             }
         }
 
     }
 
     protected void sendChunk(EntityPlayer entityplayer, ChunkCoordIntPair chunkcoordintpair, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Paper start - add x, z parameters
+        this.sendChunk(entityplayer, chunkcoordintpair.x, chunkcoordintpair.z, apacket, flag, flag1);
+    }
+    protected void sendChunk(EntityPlayer entityplayer, int chunkX, int chunkZ, Packet<?>[] apacket, boolean flag, boolean flag1) {
+        // Paper end
         if (entityplayer.world == this.world) {
             if (flag1 && !flag) {
-                PlayerChunk playerchunk = this.getVisibleChunk(chunkcoordintpair.pair());
+                PlayerChunk playerchunk = this.getVisibleChunk(ChunkCoordIntPair.pair(chunkX, chunkZ)); // Paper
 
                 if (playerchunk != null) {
                     Chunk chunk = playerchunk.getChunk();
@@ -1041,12 +1112,12 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         this.a(entityplayer, apacket, chunk);
                     }
 
-                    PacketDebug.a(this.world, chunkcoordintpair);
+                    //PacketDebug.a(this.world, chunkcoordintpair); // Paper
                 }
             }
 
             if (!flag1 && flag) {
-                entityplayer.a(chunkcoordintpair);
+                entityplayer.sendChunkUnload(chunkX, chunkZ);
             }
 
         }
@@ -1268,6 +1339,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         });
     }
 
+    private boolean cannotLoadChunks(EntityPlayer entityplayer) { return this.b(entityplayer); } // Paper - OBFHELPER
     private boolean b(EntityPlayer entityplayer) {
         return entityplayer.isSpectator() && !this.world.getGameRules().getBoolean(GameRules.SPECTATORS_GENERATE_CHUNKS);
     }
@@ -1293,13 +1365,11 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             }
         }
 
-        for (int k = i - this.viewDistance; k <= i + this.viewDistance; ++k) {
-            for (int l = j - this.viewDistance; l <= j + this.viewDistance; ++l) {
-                ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k, l);
-
-                this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], !flag, flag);
-            }
+        // Paper start - view distance map handles this
+        if (flag) {
+            this.updateMaps(entityplayer);
         }
+        // Paper end
 
     }
 
@@ -1312,7 +1382,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
     }
 
     public void movePlayer(EntityPlayer entityplayer) {
-        this.updateMaps(entityplayer); // Paper - distance maps
+        //this.updateMaps(entityplayer); // Paper - distance maps // Paper - per view distance map, this must be moved until after section updates
         ObjectIterator objectiterator = this.trackedEntities.values().iterator();
 
         while (objectiterator.hasNext()) {
@@ -1363,54 +1433,53 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
         int k1;
         int l1;
 
-        if (Math.abs(i1 - i) <= this.viewDistance * 2 && Math.abs(j1 - j) <= this.viewDistance * 2) {
-            k1 = Math.min(i, i1) - this.viewDistance;
-            l1 = Math.min(j, j1) - this.viewDistance;
-            int i2 = Math.max(i, i1) + this.viewDistance;
-            int j2 = Math.max(j, j1) + this.viewDistance;
+        this.updateMaps(entityplayer); // Paper - replaced by callbacks in the view distance map
+
+    }
+
+    @Override
+    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
+        // Paper start - per player view distance
+        // there can be potential desync with player's last mapped section and the view distance map, so use the
+        // view distance map here.
+        com.destroystokyo.paper.util.misc.PooledLinkedHashSets.PooledObjectLinkedOpenHashSet<EntityPlayer> inRange = this.playerViewDistanceBroadcastMap.getObjectsInRange(chunkcoordintpair);
+
+        if (inRange == null) {
+            return Stream.empty();
+        }
+        // all current cases are inlined so we wont hit this code, it's just in case plugins or future updates use it
+        List<EntityPlayer> players = new ArrayList<>();
+        Object[] backingSet = inRange.getBackingSet();
+
+        if (flag) { // flag -> border only
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
+                }
+                EntityPlayer player = (EntityPlayer)temp;
+                int viewDistance = this.playerViewDistanceBroadcastMap.getLastViewDistance(player);
+                long lastPosition = this.playerViewDistanceBroadcastMap.getLastCoordinate(player);
 
-            for (int k2 = k1; k2 <= i2; ++k2) {
-                for (int l2 = l1; l2 <= j2; ++l2) {
-                    ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(k2, l2);
-                    boolean flag3 = a(chunkcoordintpair, i1, j1) <= this.viewDistance;
-                    boolean flag4 = a(chunkcoordintpair, i, j) <= this.viewDistance;
+                int distX = Math.abs(MCUtil.getCoordinateX(lastPosition) - chunkcoordintpair.x);
+                int distZ = Math.abs(MCUtil.getCoordinateZ(lastPosition) - chunkcoordintpair.z);
 
-                    this.sendChunk(entityplayer, chunkcoordintpair, new Packet[2], flag3, flag4);
+                if (Math.max(distX, distZ) == viewDistance) {
+                    players.add(player);
                 }
             }
         } else {
-            ChunkCoordIntPair chunkcoordintpair1;
-            boolean flag5;
-            boolean flag6;
-
-            for (k1 = i1 - this.viewDistance; k1 <= i1 + this.viewDistance; ++k1) {
-                for (l1 = j1 - this.viewDistance; l1 <= j1 + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = true;
-                    flag6 = false;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], true, false);
-                }
-            }
-
-            for (k1 = i - this.viewDistance; k1 <= i + this.viewDistance; ++k1) {
-                for (l1 = j - this.viewDistance; l1 <= j + this.viewDistance; ++l1) {
-                    chunkcoordintpair1 = new ChunkCoordIntPair(k1, l1);
-                    flag5 = false;
-                    flag6 = true;
-                    this.sendChunk(entityplayer, chunkcoordintpair1, new Packet[2], false, true);
+            for (int i = 0, len = backingSet.length; i < len; ++i) {
+                Object temp = backingSet[i];
+                if (!(temp instanceof EntityPlayer)) {
+                    continue;
                 }
+                EntityPlayer player = (EntityPlayer)temp;
+                players.add(player);
             }
         }
-
-    }
-
-    @Override
-    public Stream<EntityPlayer> a(ChunkCoordIntPair chunkcoordintpair, boolean flag) {
-        return this.playerMap.a(chunkcoordintpair.pair()).filter((entityplayer) -> {
-            int i = b(chunkcoordintpair, entityplayer, true);
-
-            return i > this.viewDistance ? false : !flag || i == this.viewDistance;
-        });
+        return players.stream();
+        // Paper end
     }
 
     protected void addEntity(Entity entity) {
@@ -1662,7 +1731,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
             org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
             if (entityplayer != this.tracker) {
                 Vec3D vec3d = entityplayer.getPositionVector().d(this.tracker.getPositionVector()); // MC-155077, SPIGOT-5113
-                int i = Math.min(this.b(), (PlayerChunkMap.this.viewDistance - 1) * 16);
+                int i = Math.min(this.b(), (entityplayer.getEffectiveViewDistance(PlayerChunkMap.this.viewDistance)) * 16); // Paper - per player view distance
                 boolean flag = vec3d.x >= (double) (-i) && vec3d.x <= (double) i && vec3d.z >= (double) (-i) && vec3d.z <= (double) i && this.tracker.a(entityplayer);
 
                 if (flag) {
@@ -1673,7 +1742,7 @@ public class PlayerChunkMap extends IChunkLoader implements PlayerChunk.d {
                         PlayerChunk playerchunk = PlayerChunkMap.this.getVisibleChunk(chunkcoordintpair.pair());
 
                         if (playerchunk != null && playerchunk.getChunk() != null) {
-                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.viewDistance;
+                            flag1 = PlayerChunkMap.b(chunkcoordintpair, entityplayer, false) <= PlayerChunkMap.this.playerViewDistanceBroadcastMap.getLastViewDistance(entityplayer); // Paper - per player view distance
                         }
                     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 7b79ee4fe..98a876ad5 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -156,7 +156,7 @@ public abstract class PlayerList {
 
         // CraftBukkit - getType()
         // Spigot - view distance
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), worldserver.spigotConfig.viewDistance, flag1, !flag));
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), WorldData.c(worlddata.getSeed()), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getType(), this.getMaxPlayers(), worlddata.getType(), entityplayer.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap.viewDistance), flag1, !flag)); // Paper - per player view distance
         entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
         playerconnection.sendPacket(new PacketPlayOutCustomPayload(PacketPlayOutCustomPayload.a, (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
         playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
@@ -700,7 +700,7 @@ public abstract class PlayerList {
         WorldData worlddata = worldserver.getWorldData();
 
         entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(worldserver.worldProvider.getDimensionManager().getType(),  WorldData.c(worldserver.getWorldData().getSeed()), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance(worldserver.spigotConfig.viewDistance)); // Spigot
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutViewDistance((entityplayer1.getEffectiveViewDistance(worldserver.getChunkProvider().playerChunkMap.viewDistance)))); // Spigot // Paper - per player view distance
         entityplayer1.spawnIn(worldserver);
         entityplayer1.dead = false;
         entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX(), entityplayer1.locY(), entityplayer1.locZ(), entityplayer1.yaw, entityplayer1.pitch));
@@ -1178,7 +1178,7 @@ public abstract class PlayerList {
 
     public void a(int i) {
         this.viewDistance = i;
-        this.sendAll(new PacketPlayOutViewDistance(i));
+        //this.sendAll(new PacketPlayOutViewDistance(i)); // Paper - moved into PlayerChunkMap#updateViewDistance
         Iterator iterator = this.server.getWorlds().iterator();
 
         while (iterator.hasNext()) {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 10c653e8e..53b3ae2c1 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -1926,6 +1926,24 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
     // Paper end
 
+    // Paper start - per player view distance api
+    @Override
+    public int getViewDistance() {
+        return getHandle().getEffectiveViewDistance();
+    }
+
+    @Override
+    public void setViewDistance(int viewDistance) {
+        org.spigotmc.AsyncCatcher.catchOp("Player view distance update");
+        if ((viewDistance < 2 || viewDistance > 32) && viewDistance != -1) {
+            throw new IllegalArgumentException("View distance " + viewDistance + " is out of range of [2, 32]");
+        }
+        if (viewDistance != getHandle().viewDistance) {
+            ((WorldServer)getHandle().world).getChunkProvider().playerChunkMap.updateViewDistance(getHandle(), viewDistance);
+        }
+    }
+    // Paper end
+
     @Override
     public void updateCommands() {
         if (getHandle().playerConnection == null) return;
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 92601c581..0df0c73f7 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -119,14 +119,16 @@ public class ActivationRange
         final int animalActivationRange = world.spigotConfig.animalActivationRange;
         final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
 
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, raiderActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+        // Paper start - per player view distance
+        int maxRangeTemp = Math.max( monsterActivationRange, animalActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, raiderActivationRange );
+        maxRangeTemp = Math.max( maxRangeTemp, miscActivationRange );
+        // Paper end
 
         for ( EntityHuman player : world.getPlayers() )
         {
 
+            final int maxRange = Math.min( ( ( player instanceof net.minecraft.server.EntityPlayer ? ((net.minecraft.server.EntityPlayer)player).getEffectiveViewDistance() : world.spigotConfig.viewDistance ) << 4 ) - 8, maxRangeTemp ); // Paper - per player view distance
             player.activatedTick = MinecraftServer.currentTick;
             maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
             ActivationType.MISC.boundingBox = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
-- 
2.24.0.windows.2

